# DeepWiki Q&A with Code Context for Repository: badsector666/tvws
## Q1
What could we possibly do to improve or enhance the index.ts? It could be architecture, or code quality, or others that you can think of.
### Answer
# Potential Improvements for index.ts

Based on the current implementation in `src/index.ts`, here are several areas where the code could be enhanced:

## Architecture Improvements

**1. Separate concerns into modules**<cite />

The entire library is contained in a single 746-line file tvws:1-1 . Consider splitting into:
- `connection.ts` - WebSocket connection logic (`connectToEndpoint`, `parseMessage`) tvws:169-259
- `candles.ts` - Data retrieval functions (`getCandles`, `getCandlesConcurrent`, `getCandlesStream`) tvws:261-745
- `types.ts` - Type definitions and interfaces tvws:3-56
- `validation.ts` - Input validation logic tvws:67-130

**2. Extract protocol handling**<cite />

The WebSocket message protocol logic is embedded in `parseMessage` and event handlers tvws:146-167 . Create a dedicated protocol layer to handle TradingView's message format (`~m~{length}~m~` delimiters) tvws:151-152 .

## Code Quality Improvements

**3. Add comprehensive error handling**<cite />

Current error handling is minimal. The connection timeout only logs to console tvws:197-204 , and symbol errors are silently marked tvws:341-343 . Consider:
- Custom error classes for different failure modes
- Retry logic with exponential backoff
- Better error messages with context

**4. Reduce code duplication**<cite />

The three candle retrieval functions share significant logic:
- Event subscription setup tvws:285-377 tvws:432-521 tvws:657-726
- Batch size calculation tvws:269-269 tvws:415-415 tvws:649-649
- Candle processing tvws:351-358 tvws:493-500 tvws:689-696

Extract shared logic into helper functions.

**5. Improve type safety**<cite />

- The `send` function accepts `any[]` for params tvws:29-29
- Message payload uses `any` for data tvws:24-24
- Define specific types for each message type and command

**6. Add input validation**<cite />

Missing validation for:
- Symbol format (currently no validation before sending) tvws:388-392
- Amount parameter (negative values, zero)
- Connection state before operations

## Performance Improvements

**7. Optimize memory usage**<cite />

The `getCandlesStream` function uses polling with `setTimeout` tvws:556-556  instead of event-driven yielding. Consider using async iterators with proper event-based signaling.

**8. Add connection pooling**<cite />

Currently, each `connect()` call creates a new WebSocket tvws:194-194 . For applications making multiple requests, connection reuse would improve performance.

## Developer Experience

**9. Add logging infrastructure**<cite />

Replace `console.log` and `console.warn` calls tvws:606-608 tvws:618-618  with a configurable logger that can be disabled in production.

**10. Add JSDoc documentation**<cite />

Only `validateTimeframe` has JSDoc comments tvws:61-66 . Add documentation for all exported functions, especially the three candle retrieval methods and their different use cases.

**11. Export more types**<cite />

Currently only `Candle`, `TradingviewConnection`, and `TradingviewEndpoint` are exported tvws:13-20 tvws:27-31 tvws:133-137 . Export `GetCandlesParams`, `ConnectionOptions`, and other useful types for better TypeScript integration.

## Testing & Reliability

**12. Add unit tests**<cite />

No test infrastructure exists in the package tvws:25-29 . Add tests for:
- `validateTimeframe` logic
- `parseMessage` protocol handling
- Error scenarios

**13. Add connection health checks**<cite />

The ping/pong mechanism exists tvws:238-240  but isn't used for health monitoring. Implement automatic reconnection on connection loss.

## Notes

The most impactful improvements would be: (1) splitting the monolithic file into modules for maintainability, (2) reducing code duplication between the three candle functions, and (3) improving error handling throughout. The current implementation is functional but would benefit from better separation of concerns and more defensive programming practices<cite />.

Wiki pages you might want to explore:
- [Core Library API (badsector666/tvws)](/wiki/badsector666/tvws#3)
### Citations
**File:** src/index.ts (L1-1)
```typescript
const MAX_BATCH_SIZE = 5000; // found experimentally
```
**File:** src/index.ts (L3-56)
```typescript
type Subscriber = (event: TradingviewEvent) => void;
type Unsubscriber = () => void;

type MessageType = "ping" | "session" | "event";

interface RawCandle {
  i: number;
  v: number[];
}

export interface Candle {
  timestamp: number;
  high: number;
  low: number;
  open: number;
  close: number;
  volume: number;
}

interface MessagePayload {
  type: MessageType;
  data: any;
}

interface TradingviewConnection {
  subscribe: (handler: Subscriber) => Unsubscriber;
  send: (name: string, params: any[]) => void;
  close: () => Promise<void>;
}

interface ConnectionOptions {
  sessionId?: string;
  endpoint?: string;
}

interface TradingviewEvent {
  name: string;
  params: any[];
}

type TradingviewTimeframe =
  | "1"
  | "3"
  | "5"
  | "15"
  | "30"
  | "45"
  | "60"
  | "120"
  | "180"
  | "240"
  | "1D"
  | "1W"
  | "1M";
```
**File:** src/index.ts (L61-66)
```typescript
/**
 * Validates and normalizes timeframe input to TradingView API format
 * @param timeframe - The timeframe to validate (can be number or various string formats)
 * @returns Valid TradingView timeframe string
 * @throws Error if timeframe format is invalid
 */
```
**File:** src/index.ts (L67-130)
```typescript
function validateTimeframe(timeframe: FlexibleTimeframe): TradingviewTimeframe {
  // If already a valid timeframe string, return as is
  const validTimeframes: TradingviewTimeframe[] = [
    "1",
    "3",
    "5",
    "15",
    "30",
    "45",
    "60",
    "120",
    "180",
    "240",
    "1D",
    "1W",
    "1M",
  ];

  if (
    typeof timeframe === "string" &&
    validTimeframes.includes(timeframe as TradingviewTimeframe)
  ) {
    return timeframe as TradingviewTimeframe;
  }

  // Convert numeric timeframes to string
  if (typeof timeframe === "number") {
    const timeframeStr = timeframe.toString();
    if (validTimeframes.includes(timeframeStr as TradingviewTimeframe)) {
      return timeframeStr as TradingviewTimeframe;
    }
  }

  // Convert common invalid string formats to valid ones
  if (typeof timeframe === "string") {
    const timeframeMap: Record<string, TradingviewTimeframe> = {
      "1m": "1",
      "3m": "3",
      "5m": "5",
      "15m": "15",
      "30m": "30",
      "45m": "45",
      "1h": "60",
      "2h": "120",
      "3h": "180",
      "4h": "240",
      "1d": "1D",
      "1w": "1W",
      "1M": "1M",
      D: "1D",
      W: "1W",
      M: "1M",
    };

    const normalized = timeframe.toLowerCase();
    if (timeframeMap[normalized]) {
      return timeframeMap[normalized];
    }
  }

  throw new Error(
    `Invalid timeframe: ${timeframe}. Valid timeframes are: ${validTimeframes.join(", ")}`,
  );
}
```
**File:** src/index.ts (L133-137)
```typescript
export type TradingviewEndpoint =
  | "data" // Default for free users
  | "prodata" // Premium users
  | "widgetdata" // Widget data
  | "charts-polygon"; // Polygon data
```
**File:** src/index.ts (L146-167)
```typescript
function parseMessage(message: string): MessagePayload[] {
  if (message.length === 0) return [];

  const events = message
    .toString()
    .split(/~m~\d+~m~/)
    .slice(1);

  return events.map((event) => {
    if (event.substring(0, 3) === "~h~") {
      return { type: "ping", data: `~m~${event.length}~m~${event}` };
    }

    const parsed = JSON.parse(event);

    if (parsed["session_id"]) {
      return { type: "session", data: parsed };
    }

    return { type: "event", data: parsed };
  });
}
```
**File:** src/index.ts (L169-259)
```typescript
async function connectToEndpoint(
  options: ConnectionOptions,
  endpointName: string,
  wsUrl: string,
): Promise<TradingviewConnection> {
  let token = "unauthorized_user_token";

  if (options.sessionId) {
    try {
      const resp = await fetch("https://www.tradingview.com/disclaimer/", {
        method: "GET",
        headers: { Cookie: `sessionid=${options.sessionId}` },
        credentials: "include",
      });
      const text = await resp.text();
      const match = text.match(/"auth_token":"(.+?)"/);
      if (match) {
        token = match[1];
      }
    } catch (error) {
      console.warn("Authentication failed, using unauthorized token:", error);
      // Keep the default unauthorized token
    }
  }

  const connection = new WebSocket(wsUrl);

  // Add connection timeout to prevent hanging
  const connectionTimeout = setTimeout(() => {
    if (connection.readyState === WebSocket.CONNECTING) {
      connection.close();
      throw new Error(
        "Connection timeout - WebSocket did not connect within 10 seconds",
      );
    }
  }, 10000);

  const subscribers: Set<Subscriber> = new Set();

  function subscribe(handler: Subscriber): Unsubscriber {
    subscribers.add(handler);
    return () => {
      subscribers.delete(handler);
    };
  }

  function send(name: string, params: any[]) {
    const data = JSON.stringify({ m: name, p: params });
    const message = "~m~" + data.length + "~m~" + data;
    connection.send(message);
  }

  async function close() {
    return new Promise<void>((resolve, reject) => {
      connection.addEventListener("close", () => resolve());
      connection.addEventListener("error", (error) => reject(error));
      connection.close();
    });
  }

  return new Promise<TradingviewConnection>((resolve, reject) => {
    connection.addEventListener("error", (error: Event) => reject(error));

    connection.addEventListener("message", (event: MessageEvent) => {
      const message = event.data;
      const payloads = parseMessage(message.toString());

      for (const payload of payloads) {
        switch (payload.type) {
          case "ping":
            connection.send(payload.data);
            break;
          case "session":
            clearTimeout(connectionTimeout);
            send("set_auth_token", [token]);
            resolve({ subscribe, send, close });
            break;
          case "event":
            const tradingEvent = {
              name: payload.data.m,
              params: payload.data.p,
            };
            subscribers.forEach((handler) => handler(tradingEvent));
            break;
          default:
            throw new Error(`unknown payload: ${payload}`);
        }
      }
    });
  });
}
```
**File:** src/index.ts (L261-745)
```typescript
export async function getCandlesConcurrent({
  connection,
  symbols,
  amount,
  timeframe = 60,
}: GetCandlesParams): Promise<Candle[][]> {
  if (symbols.length === 0) return [];

  const batchSize = amount && amount < MAX_BATCH_SIZE ? amount : MAX_BATCH_SIZE;
  const symbolStates = new Map<string, SymbolState>();
  const sessionMap = new Map<string, string>(); // session -> symbol
  const results: Candle[][] = [];
  let completedCount = 0;

  return new Promise<Candle[][]>((resolve, reject) => {
    // Initialize state for each symbol
    for (const symbol of symbols) {
      symbolStates.set(symbol, {
        candles: [],
        completed: false,
        error: false,
      });
    }

    const unsubscribe = connection.subscribe((event) => {
      try {
        // Handle candle updates
        if (event.name === "timescale_update") {
          const sessionData = event.params[1];
          const sessionId = event.params[0];
          const symbol = sessionMap.get(sessionId);

          if (!symbol) return;

          const state = symbolStates.get(symbol);
          if (!state || state.completed) return;

          // Find the series data (could be sds_1 or other series)
          const seriesKey = Object.keys(sessionData).find(
            (key) => key.startsWith("sds_") && sessionData[key].s,
          );

          if (seriesKey) {
            let newCandles: RawCandle[] = sessionData[seriesKey].s;
            if (newCandles.length > batchSize) {
              // Remove already received candles
              newCandles = newCandles.slice(0, -state.candles.length);
            }
            state.candles = newCandles.concat(state.candles);
          }
          return;
        }

        // Handle completion or error
        if (["series_completed", "symbol_error"].includes(event.name)) {
          const sessionId = event.params[0];
          const symbol = sessionMap.get(sessionId);

          if (!symbol) return;

          const state = symbolStates.get(symbol);
          if (!state || state.completed) return;

          // Check if we need more data
          const loadedCount = state.candles.length;
          if (
            loadedCount > 0 &&
            loadedCount % batchSize === 0 &&
            (!amount || loadedCount < amount)
          ) {
            connection.send("request_more_data", [
              sessionId,
              "sds_1",
              batchSize,
            ]);
            return;
          }

          // Mark as completed
          state.completed = true;
          if (event.name === "symbol_error") {
            state.error = true;
          }

          // Process the candles
          let finalCandles = state.candles;
          if (amount) {
            finalCandles = finalCandles.slice(0, amount);
          }

          const processedCandles = finalCandles.map((c) => ({
            timestamp: c.v[0],
            open: c.v[1],
            high: c.v[2],
            low: c.v[3],
            close: c.v[4],
            volume: c.v[5],
          }));

          // Store results in original order
          const originalIndex = symbols.indexOf(symbol);
          results[originalIndex] = processedCandles;

          completedCount++;

          // Check if all symbols are completed
          if (completedCount === symbols.length) {
            unsubscribe();
            resolve(results);
          }
          return;
        }
      } catch (error) {
        console.error("Error processing event:", error);
        reject(error);
      }
    });

    // Send all requests concurrently
    for (let i = 0; i < symbols.length; i++) {
      const symbol = symbols[i];
      const chartSession = `cs_${symbol}_${Math.random().toString(36).substring(2, 14)}`;
      const symbolSession = `sds_sym_${i}`;

      sessionMap.set(chartSession, symbol);

      connection.send("chart_create_session", [chartSession, ""]);
      connection.send("resolve_symbol", [
        chartSession,
        symbolSession,
        "=" + JSON.stringify({ symbol, adjustment: "splits" }),
      ]);
      const validatedTimeframe = validateTimeframe(timeframe);
      connection.send("create_series", [
        chartSession,
        "sds_1",
        `s${i}`,
        symbolSession,
        validatedTimeframe,
        batchSize,
        "",
      ]);
    }
  });
}

export async function* getCandlesStream({
  connection,
  symbols,
  amount,
  timeframe = 60,
}: GetCandlesParams): AsyncGenerator<Candle[], void, unknown> {
  if (symbols.length === 0) return;

  const batchSize = amount && amount < MAX_BATCH_SIZE ? amount : MAX_BATCH_SIZE;
  const symbolStates = new Map<string, SymbolState>();
  const sessionMap = new Map<string, string>(); // session -> symbol
  const pendingYields: Array<{ symbol: string; candles: Candle[] }> = [];
  let activeCount = symbols.length;
  let hasError = false;
  let errorMessage: string | null = null;

  // Initialize state for each symbol
  for (const symbol of symbols) {
    symbolStates.set(symbol, {
      candles: [],
      completed: false,
      error: false,
    });
  }

  const unsubscribe = connection.subscribe((event) => {
    try {
      // Handle candle updates
      if (event.name === "timescale_update") {
        const sessionData = event.params[1];
        const sessionId = event.params[0];
        const symbol = sessionMap.get(sessionId);

        if (!symbol) return;

        const state = symbolStates.get(symbol);
        if (!state || state.completed) return;

        // Find the series data
        const seriesKey = Object.keys(sessionData).find(
          (key) => key.startsWith("sds_") && sessionData[key].s,
        );

        if (seriesKey) {
          let newCandles: RawCandle[] = sessionData[seriesKey].s;
          if (newCandles.length > batchSize) {
            newCandles = newCandles.slice(0, -state.candles.length);
          }
          state.candles = newCandles.concat(state.candles);
        }
        return;
      }

      // Handle completion or error
      if (["series_completed", "symbol_error"].includes(event.name)) {
        const sessionId = event.params[0];
        const symbol = sessionMap.get(sessionId);

        if (!symbol) return;

        const state = symbolStates.get(symbol);
        if (!state || state.completed) return;

        // Check if we need more data
        const loadedCount = state.candles.length;
        if (
          loadedCount > 0 &&
          loadedCount % batchSize === 0 &&
          (!amount || loadedCount < amount)
        ) {
          connection.send("request_more_data", [sessionId, "sds_1", batchSize]);
          return;
        }

        // Mark as completed
        state.completed = true;
        if (event.name === "symbol_error") {
          state.error = true;
        }

        // Process the candles
        let finalCandles = state.candles;
        if (amount) {
          finalCandles = finalCandles.slice(0, amount);
        }

        const processedCandles = finalCandles.map((c) => ({
          timestamp: c.v[0],
          open: c.v[1],
          high: c.v[2],
          low: c.v[3],
          close: c.v[4],
          volume: c.v[5],
        }));

        // Add to pending yields
        if (processedCandles.length > 0 || !state.error) {
          pendingYields.push({ symbol, candles: processedCandles });
        }

        activeCount--;

        // Clean up if all symbols are done
        if (activeCount === 0) {
          unsubscribe();
        }
        return;
      }
    } catch (error) {
      console.error("Error processing event:", error);
      hasError = true;
      errorMessage = error instanceof Error ? error.message : String(error);
      unsubscribe();
    }
  });

  // Send all requests concurrently
  for (let i = 0; i < symbols.length; i++) {
    const symbol = symbols[i];
    const chartSession = `cs_${symbol}_${Math.random().toString(36).substring(2, 14)}`;
    const symbolSession = `sds_sym_${i}`;

    sessionMap.set(chartSession, symbol);

    connection.send("chart_create_session", [chartSession, ""]);
    connection.send("resolve_symbol", [
      chartSession,
      symbolSession,
      "=" + JSON.stringify({ symbol, adjustment: "splits" }),
    ]);
    const validatedTimeframe = validateTimeframe(timeframe);
    connection.send("create_series", [
      chartSession,
      "sds_1",
      `s${i}`,
      symbolSession,
      validatedTimeframe,
      batchSize,
      "",
    ]);
  }

  // Yield results as they become available
  while (activeCount > 0 && !hasError) {
    if (pendingYields.length > 0) {
      const { candles } = pendingYields.shift()!;
      yield candles;
    } else {
      // Wait a bit for more results
      await new Promise((resolve) => setTimeout(resolve, 50));
    }
  }

  // Throw error if one occurred
  if (hasError && errorMessage) {
    throw new Error(errorMessage);
  }

  // Yield any remaining results
  while (pendingYields.length > 0) {
    const { candles } = pendingYields.shift()!;
    yield candles;
  }
}

export async function connect(
  options: ConnectionOptions = {},
): Promise<TradingviewConnection> {
  // Determine WebSocket endpoint
  let endpointName: string;
  let wsUrl: string;

  if (options.endpoint && Object.keys(ENDPOINTS).includes(options.endpoint)) {
    // If named endpoint provided
    endpointName = options.endpoint;
    wsUrl = ENDPOINTS[options.endpoint as TradingviewEndpoint];
  } else if (options.endpoint && options.endpoint.startsWith("wss://")) {
    // If custom endpoint provided
    endpointName = "custom";
    wsUrl = options.endpoint;
  } else {
    // Default to data endpoint for free users
    endpointName = "data";
    wsUrl = ENDPOINTS.data;
  }

  // Try to connect with fallback to other endpoints
  const endpointsToTry = [
    { name: endpointName, url: wsUrl },
    // Add fallback endpoints (excluding the one we already tried)
    ...Object.entries(ENDPOINTS)
      .filter(([name]) => name !== endpointName)
      .map(([name, url]) => ({ name, url })),
  ];

  let lastError: Error | null = null;

  for (const endpoint of endpointsToTry) {
    try {
      console.log(
        `Attempting connection to ${endpoint.name} endpoint: ${endpoint.url}`,
      );
      const connection = await connectToEndpoint(
        options,
        endpoint.name,
        endpoint.url,
      );
      console.log(`Successfully connected to ${endpoint.name} endpoint`);
      return connection;
    } catch (error) {
      lastError = error as Error;
      console.warn(`Failed to connect to ${endpoint.name} endpoint:`, error);
      // Continue to next endpoint
    }
  }

  // If all endpoints failed, throw the last error
  throw lastError || new Error("Failed to connect to any TradingView endpoint");
}

interface GetCandlesParams {
  connection: TradingviewConnection;
  symbols: string[];
  amount?: number;
  timeframe?: FlexibleTimeframe;
}

interface SymbolState {
  candles: RawCandle[];
  completed: boolean;
  error?: boolean;
}

export async function getCandles({
  connection,
  symbols,
  amount,
  timeframe = 60,
}: GetCandlesParams) {
  if (symbols.length === 0) return [];

  const chartSession = "cs_" + Math.random().toString(36).substring(2, 14);
  const batchSize = amount && amount < MAX_BATCH_SIZE ? amount : MAX_BATCH_SIZE;

  return new Promise<Candle[][]>((resolve) => {
    const allCandles: Candle[][] = [];
    let currentSymIndex = 0;
    let symbol = symbols[currentSymIndex];
    let currentSymCandles: RawCandle[] = [];

    const unsubscribe = connection.subscribe((event) => {
      // received new candles
      if (event.name === "timescale_update") {
        let newCandles: RawCandle[] = event.params[1]["sds_1"]["s"];
        if (newCandles.length > batchSize) {
          // sometimes tradingview sends already received candles
          newCandles = newCandles.slice(0, -currentSymCandles.length);
        }
        currentSymCandles = newCandles.concat(currentSymCandles);
        return;
      }

      // loaded all requested candles
      if (["series_completed", "symbol_error"].includes(event.name)) {
        const loadedCount = currentSymCandles.length;
        if (
          loadedCount > 0 &&
          loadedCount % batchSize === 0 &&
          (!amount || loadedCount < amount)
        ) {
          connection.send("request_more_data", [
            chartSession,
            "sds_1",
            batchSize,
          ]);
          return;
        }

        // loaded all candles for current symbol

        if (amount) currentSymCandles = currentSymCandles.slice(0, amount);

        const candles = currentSymCandles.map((c) => ({
          timestamp: c.v[0],
          open: c.v[1],
          high: c.v[2],
          low: c.v[3],
          close: c.v[4],
          volume: c.v[5],
        }));
        allCandles.push(candles);

        // next symbol
        if (symbols.length - 1 > currentSymIndex) {
          currentSymCandles = [];
          currentSymIndex += 1;
          symbol = symbols[currentSymIndex];
          connection.send("resolve_symbol", [
            chartSession,
            `sds_sym_${currentSymIndex}`,
            "=" + JSON.stringify({ symbol, adjustment: "splits" }),
          ]);

          const validatedTimeframe = validateTimeframe(timeframe);
          connection.send("modify_series", [
            chartSession,
            "sds_1",
            `s${currentSymIndex}`,
            `sds_sym_${currentSymIndex}`,
            validatedTimeframe,
            "",
          ]);
          return;
        }

        // all symbols loaded
        unsubscribe();
        resolve(allCandles);
      }
    });

    connection.send("chart_create_session", [chartSession, ""]);
    connection.send("resolve_symbol", [
      chartSession,
      `sds_sym_0`,
      "=" + JSON.stringify({ symbol, adjustment: "splits" }),
    ]);
    const validatedTimeframe = validateTimeframe(timeframe);
    connection.send("create_series", [
      chartSession,
      "sds_1",
      "s0",
      "sds_sym_0",
      validatedTimeframe,
      batchSize,
      "",
    ]);
  });
}
```
**File:** package.json (L25-29)
```json
  "scripts": {
    "build": "tsc",
    "prepublishOnly": "npm run typecheck && npm run build",
    "typecheck": "tsc --noEmit"
  },
```
## Q2
Based on your concern, how will the use of CDN if we split it to modules? Is it more complex or it will more simple?
### Answer
You're asking about how splitting `src/index.ts` into multiple modules would affect CDN usage, specifically whether it would make the library more complex or simpler to use via CDN.<cite />

## Impact on CDN Usage

Splitting into modules would actually **simplify** CDN usage in most cases, but requires careful build configuration.<cite />

### Current Single-File Approach

Right now, the library compiles to a single `dist/index.js` file that can be imported directly from CDN: tvws:26-28

The example application uses dynamic imports to load this single bundle: tvws:12-13

### After Splitting into Modules

If you split `src/index.ts` into separate modules (`connection.ts`, `candles.ts`, `types.ts`, `validation.ts`), you have two options:<cite />

**Option 1: Bundle to Single File (Recommended for CDN)**

Keep the build process bundling everything into a single `dist/index.js`.<cite /> This maintains the current CDN usage pattern with **no changes required** for users:<cite />

- TypeScript compiler or bundler (like esbuild/rollup) combines all modules into one output file
- CDN imports remain exactly the same
- Users still get tree-shaking benefits if they use a bundler locally
- The example app continues to work without modification

**Option 2: Publish Multiple Module Files**

Export separate files like `dist/connection.js`, `dist/candles.js`, etc.<cite /> This would:

- Allow users to import only what they need: `import { connect } from 'https://unpkg.com/tvws@latest/dist/connection.js'`
- Reduce initial bundle size for users who only need specific functionality
- **But** adds complexity - users must know which module contains which function
- Requires updating the example app to import from multiple URLs

## Recommendation

**Keep bundling to a single file** for CDN distribution.<cite /> The package.json already configures this: tvws:10-19

Your source code can be split into multiple modules for maintainability, but the build output remains a single `dist/index.js` that exports everything.<cite /> This gives you:

- ✅ Better code organization internally
- ✅ No breaking changes for CDN users
- ✅ Same simple import syntax in the example app
- ✅ Bundlers can still tree-shake unused code when users install via npm

The example's dynamic import strategy would continue to work identically: tvws:7-29

## Notes

The current build setup using TypeScript (`tsc`) already supports this pattern - you can split your source into multiple `.ts` files and configure `tsconfig.json` to bundle them into a single output. tvws:26-26  Alternatively, you could add a bundler like esbuild or rollup for more control over the output format, but this isn't necessary for basic module splitting.<cite />

Wiki pages you might want to explore:
- [Example Application (badsector666/tvws)](/wiki/badsector666/tvws#5)
### Citations
**File:** README.MD (L26-28)
```markdown
<script type="module">
import { connect, getCandles, ENDPOINTS } from 'https://unpkg.com/tvws@latest/dist/index.js';
</script>
```
**File:** example/script.js (L7-29)
```javascript
async function loadTvwsModule() {
  if (tvwsModule) return tvwsModule;

  try {
    // Try CDN first
    tvwsModule = await import("https://unpkg.com/tvws@0.0.5/dist/index.js");
    console.log("Loaded tvws from CDN successfully");
  } catch (cdnError) {
    console.warn("CDN import failed, trying local version:", cdnError);
    try {
      // Fallback to local development version
      tvwsModule = await import("../dist/index.js");
      console.log("Loaded tvws from local version successfully");
    } catch (localError) {
      console.error("Failed to load tvws from both CDN and local:", localError);
      throw new Error(
        "Unable to load tvws module. Please check your internet connection or run 'npm run build' first.",
      );
    }
  }

  return tvwsModule;
}
```
**File:** package.json (L10-19)
```json
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "browser": "dist/index.js",
  "module": "dist/index.js",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "require": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
```
**File:** package.json (L26-26)
```json
    "build": "tsc",
```
https://deepwiki.com/search/what-could-we-possibly-do-to-i_2396eefc-b34a-4248-816a-8ffebc848a8d?mode=fast
