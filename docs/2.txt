# DeepWiki Q&A with Code Context for Repository: badsector666/tvws
## Q1
Why it's always spam message: Real-time event: du ? Here is the entire log : [8:33:09 PM] === Data Fetch Started === [8:33:09 PM] Symbols: FX:EURUSD [8:33:09 PM] Timeframes: 1D (30 candles) [8:33:09 PM] Endpoint: data [8:33:09 PM] Total requests: 1 [8:33:09 PM] Performance tracking enabled - measuring API response times [8:33:09 PM] Fetching FX:EURUSD 1D... [8:33:09 PM] 📡 Real-time event: series_loading [8:33:09 PM] 📡 Real-time event: symbol_resolved [8:33:09 PM] 📡 Real-time event: timescale_update [8:33:09 PM] 📡 Real-time event: series_completed [8:33:09 PM] ✅ FX:EURUSD 1D: 30 candles (500ms) [8:33:09 PM] Last: 1.16418 | Change: -1.22% | High: 1.18482 | Low: 1.15420 [8:33:09 PM] ✅ Results displayed in organized format [8:33:09 PM] ✅ Performance metrics displayed [8:33:09 PM] 📊 Performance Summary: 1 requests, 500ms avg, 1.82 req/sec [8:33:09 PM] === Data Fetch Completed === [8:33:09 PM] Summary: 1 successful, 0 failed requests [8:33:09 PM] Total execution time: 548ms [8:33:09 PM] 🔄 You can try different settings and fetch again [8:33:11 PM] 📡 Real-time event: du [8:33:18 PM] 📡 Real-time event: du [8:33:23 PM] 📡 Real-time event: du [8:33:28 PM] 📡 Real-time event: du [8:33:34 PM] 📡 Real-time event: du [8:33:39 PM] 📡 Real-time event: du [8:33:42 PM] 📡 Real-time event: du
### Answer
The "du" events you're seeing are **not spam messages** - they are legitimate real-time WebSocket events from TradingView that the example application is logging. tvws:258-260

## What's Happening

After your data fetch completes successfully, the WebSocket connection remains open and continues to receive events from TradingView. tvws:331-334  The connection subscribes to all events and logs them with the format `📡 Real-time event: ${event.name}`. tvws:259-259

The "du" events are internal TradingView WebSocket events. Looking at the message parsing logic in the core library, the system handles three types of payloads: "ping" (heartbeat), "session" (connection establishment), and "event" (all other messages). tvws:146-167  The "du" events fall into the "event" category and are being forwarded to all subscribers. tvws:246-251

## Why You See Them

The example application's event subscription is intentionally broad - it logs **every** event received from TradingView, not just the data-related ones like `timescale_update`, `series_completed`, etc. tvws:331-334  This is by design for debugging purposes, as noted in the UI features: "Debug Logging: Real-time log of connection and data events".<cite />

The data fetching logic only processes specific event names (`timescale_update`, `series_completed`, `symbol_error`) tvws:657-726 , but the subscription logs everything.

## Notes

These "du" events appear to be TradingView's internal keep-alive or status update messages that occur periodically (roughly every 5-7 seconds in your log). They don't affect functionality and can be safely ignored. If you want to filter them out, you could modify the subscription handler in `example/script.js` to only log specific event types instead of all events.<cite />

Wiki pages you might want to explore:
- [Example Application (badsector666/tvws)](/wiki/badsector666/tvws#5)
### Citations
**File:** example/script.js (L258-260)
```javascript
    connection.subscribe((event) => {
      log(`📡 Real-time event: ${event.name}`, "info");
    });
```
**File:** example/script.js (L331-334)
```javascript
    // Subscribe to real-time events
    connection.subscribe((event) => {
      log(`📡 Real-time event: ${event.name}`, "info");
    });
```
**File:** src/index.ts (L146-167)
```typescript
function parseMessage(message: string): MessagePayload[] {
  if (message.length === 0) return [];

  const events = message
    .toString()
    .split(/~m~\d+~m~/)
    .slice(1);

  return events.map((event) => {
    if (event.substring(0, 3) === "~h~") {
      return { type: "ping", data: `~m~${event.length}~m~${event}` };
    }

    const parsed = JSON.parse(event);

    if (parsed["session_id"]) {
      return { type: "session", data: parsed };
    }

    return { type: "event", data: parsed };
  });
}
```
**File:** src/index.ts (L246-251)
```typescript
          case "event":
            const tradingEvent = {
              name: payload.data.m,
              params: payload.data.p,
            };
            subscribers.forEach((handler) => handler(tradingEvent));
```
**File:** src/index.ts (L657-726)
```typescript
    const unsubscribe = connection.subscribe((event) => {
      // received new candles
      if (event.name === "timescale_update") {
        let newCandles: RawCandle[] = event.params[1]["sds_1"]["s"];
        if (newCandles.length > batchSize) {
          // sometimes tradingview sends already received candles
          newCandles = newCandles.slice(0, -currentSymCandles.length);
        }
        currentSymCandles = newCandles.concat(currentSymCandles);
        return;
      }

      // loaded all requested candles
      if (["series_completed", "symbol_error"].includes(event.name)) {
        const loadedCount = currentSymCandles.length;
        if (
          loadedCount > 0 &&
          loadedCount % batchSize === 0 &&
          (!amount || loadedCount < amount)
        ) {
          connection.send("request_more_data", [
            chartSession,
            "sds_1",
            batchSize,
          ]);
          return;
        }

        // loaded all candles for current symbol

        if (amount) currentSymCandles = currentSymCandles.slice(0, amount);

        const candles = currentSymCandles.map((c) => ({
          timestamp: c.v[0],
          open: c.v[1],
          high: c.v[2],
          low: c.v[3],
          close: c.v[4],
          volume: c.v[5],
        }));
        allCandles.push(candles);

        // next symbol
        if (symbols.length - 1 > currentSymIndex) {
          currentSymCandles = [];
          currentSymIndex += 1;
          symbol = symbols[currentSymIndex];
          connection.send("resolve_symbol", [
            chartSession,
            `sds_sym_${currentSymIndex}`,
            "=" + JSON.stringify({ symbol, adjustment: "splits" }),
          ]);

          const validatedTimeframe = validateTimeframe(timeframe);
          connection.send("modify_series", [
            chartSession,
            "sds_1",
            `s${currentSymIndex}`,
            `sds_sym_${currentSymIndex}`,
            validatedTimeframe,
            "",
          ]);
          return;
        }

        // all symbols loaded
        unsubscribe();
        resolve(allCandles);
      }
    });
```
## Q2
How can the user flexibly changes the log methods? Like only shows fatal, error, warn, info, debug, trace, etc. Which part must we refactor?
### Answer
You're asking about implementing flexible log level filtering in the example application, specifically to control which log messages are displayed (fatal, error, warn, info, debug, trace, etc.).

## Current Logging Implementation

The current logging system in the example application is very simple. The `log()` function in `example/script.js` accepts a message and a type parameter, but the type is only used for console output - **all messages are displayed in the UI regardless of their type** tvws:677-685 :

```javascript
function log(message, type = "info") {
  const timestamp = new Date().toLocaleTimeString();
  const logMessage = `[${timestamp}] ${message}`;
  console.log(logMessage);

  const logEl = document.getElementById("log");
  logEl.textContent += logMessage + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}
```

The `type` parameter is passed throughout the codebase (e.g., "info", "success", "error", "warning") tvws:259-259 tvws:333-333 , but it's not actually used for filtering.

## Required Refactoring

To implement flexible log level filtering, you need to refactor these parts:

### 1. **Add Log Level Configuration** (`example/script.js`)

Add a global log level configuration at the top of the file tvws:1-5 :

```javascript
let logLevel = 'info'; // Default log level
const LOG_LEVELS = {
  'trace': 0,
  'debug': 1,
  'info': 2,
  'warn': 3,
  'error': 4,
  'fatal': 5
};
```

### 2. **Refactor the `log()` Function** (`example/script.js:677-685`)

Modify the `log()` function to check the log level before displaying tvws:677-685 :

```javascript
function log(message, type = "info") {
  // Map existing types to log levels
  const typeToLevel = {
    'info': 'info',
    'success': 'info',
    'warning': 'warn',
    'error': 'error'
  };

  const level = typeToLevel[type] || 'info';

  // Filter based on log level
  if (LOG_LEVELS[level] < LOG_LEVELS[logLevel]) {
    return; // Skip this log message
  }

  const timestamp = new Date().toLocaleTimeString();
  const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;
  console.log(logMessage);

  const logEl = document.getElementById("log");
  logEl.textContent += logMessage + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}
```

### 3. **Add UI Controls** (`example/index.html`)

Add a log level selector in the debug log section tvws:312-316 :

```html
<div class="debug-log compact">
    <h3>📋 Debug Log</h3>
    <div class="form-group">
        <label for="logLevelSelect">Log Level:</label>
        <select id="logLevelSelect" onchange="setLogLevel()">
            <option value="trace">Trace (All)</option>
            <option value="debug">Debug</option>
            <option value="info" selected>Info</option>
            <option value="warn">Warning</option>
            <option value="error">Error</option>
            <option value="fatal">Fatal Only</option>
        </select>
    </div>
    <div id="log" class="log-container"></div>
</div>
```

### 4. **Add Log Level Setter Function** (`example/script.js`)

Add a new function to handle log level changes and expose it globally tvws:47-115 :

```javascript
function setLogLevel() {
  const select = document.getElementById("logLevelSelect");
  logLevel = select.value;
  log(`Log level changed to: ${logLevel.toUpperCase()}`, "info");
}

// In setupGlobalFunctions()
window.setLogLevel = function() {
  console.log("setLogLevel called via window");
  return setLogLevel();
};
```

### 5. **Update Real-time Event Logging** (`example/script.js:258-259`, `333`)

The real-time event subscriptions that log "du" events would also respect the log level tvws:258-260 tvws:332-334 . You could optionally add a separate filter for these:

```javascript
connection.subscribe((event) => {
  // Only log if debug level or lower
  if (LOG_LEVELS[logLevel] <= LOG_LEVELS['debug']) {
    log(`📡 Real-time event: ${event.name}`, "debug");
  }
});
```

## Notes

The current implementation logs everything at the same level. To properly implement log levels, you'd need to:
1. Standardize the type parameter across all `log()` calls (currently uses "info", "success", "error", "warning")
2. Map these to proper log levels (trace/debug/info/warn/error/fatal)
3. Add filtering logic in the `log()` function itself
4. Provide UI controls for users to change the log level dynamically

The "du" events specifically could be logged at the "debug" or "trace" level so they're hidden by default when users set the log level to "info" or higher<cite />.

Wiki pages you might want to explore:
- [Example Application (badsector666/tvws)](/wiki/badsector666/tvws#5)
### Citations
**File:** example/script.js (L1-5)
```javascript
// TradingView WebSocket Example - Complete Functionality
// Using dynamic import to avoid Bun bundler issues with external CDN modules
let connection = null;
let tvwsModule = null;

```
**File:** example/script.js (L47-115)
```javascript
function setupGlobalFunctions() {
  try {
    // Make all functions globally available to HTML onclick handlers
    window.toggleAuthFields = function () {
      console.log("toggleAuthFields called via window");
      return toggleAuthFields();
    };

    window.showSessionHelp = function () {
      console.log("showSessionHelp called via window");
      return showSessionHelp();
    };

    window.hideSessionHelp = function () {
      console.log("hideSessionHelp called via window");
      return hideSessionHelp();
    };

    window.quickConnect = function () {
      console.log("quickConnect called via window");
      return quickConnect();
    };

    window.testConnection = function () {
      console.log("testConnection called via window");
      return testConnection();
    };

    window.loadData = function () {
      console.log("loadData called via window");
      return loadData();
    };

    window.clearResults = function () {
      console.log("clearResults called via window");
      return clearResults();
    };

    window.clearLog = function () {
      console.log("clearLog called via window");
      return clearLog();
    };

    window.selectPresetTicker = function () {
      console.log("selectPresetTicker called via window");
      return selectPresetTicker();
    };

    window.resetQueryForm = function () {
      console.log("resetQueryForm called via window");
      return resetQueryForm();
    };

    window.log = log;

    console.log("All global functions have been set up successfully");

    // Test that functions are accessible
    console.log("Testing function accessibility:");
    console.log(
      "- toggleAuthFields available:",
      typeof window.toggleAuthFields,
    );
    console.log("- quickConnect available:", typeof window.quickConnect);
    console.log("- loadData available:", typeof window.loadData);
  } catch (error) {
    console.error("Error setting up global functions:", error);
  }
}
```
**File:** example/script.js (L258-260)
```javascript
    connection.subscribe((event) => {
      log(`📡 Real-time event: ${event.name}`, "info");
    });
```
**File:** example/script.js (L332-334)
```javascript
    connection.subscribe((event) => {
      log(`📡 Real-time event: ${event.name}`, "info");
    });
```
**File:** example/script.js (L677-685)
```javascript
function log(message, type = "info") {
  const timestamp = new Date().toLocaleTimeString();
  const logMessage = `[${timestamp}] ${message}`;
  console.log(logMessage);

  const logEl = document.getElementById("log");
  logEl.textContent += logMessage + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}
```
**File:** example/index.html (L312-316)
```html
                <!-- Debug Log -->
                <div class="debug-log compact">
                    <h3>📋 Debug Log</h3>
                    <div id="log" class="log-container"></div>
                </div>
```
## Q3
As you say before: The "du" events fall into the "event" category and are being forwarded to all subscribers. Why not unsubscribe entirely? What's the pros and cons to unsubscribe? As I don't know if waiting the connection (let's say 1 minute) will get us the next historical data for it's timeframe or update to the latest data.
### Answer
You're asking about whether to unsubscribe from the WebSocket connection after data fetching completes, specifically regarding the "du" events and whether keeping the connection open provides real-time updates.

## Why Keep the Connection Open

The connection remains subscribed after data fetching because the `TradingviewConnection` object is designed to be **reusable and long-lived** tvws:27-31 . The subscription system allows multiple handlers to listen to the same connection tvws:206-213 .

In the data fetching functions (`getCandles`, `getCandlesConcurrent`, `getCandlesStream`), the subscription is **explicitly unsubscribed** once data collection completes tvws:723-724 tvws:368-369 tvws:510-512 . However, the **example application adds its own separate subscription** that logs all events and never unsubscribes tvws:332-334 .

## Real-time Updates: The Answer

**No, keeping the connection open does NOT automatically provide real-time price updates for your historical data request.**<cite />

Here's why:

1. **Historical data requests are one-time operations**: When you call `getCandles()` or similar functions, they create a chart session, request data, wait for `series_completed`, then unsubscribe tvws:728-744 .

2. **Real-time updates require active series**: To receive live price updates, you would need to keep the chart session active and continue listening for `timescale_update` events. The current implementation **closes the subscription** after receiving `series_completed` tvws:670-725 .

3. **The "du" events are not price updates**: These are TradingView's internal protocol messages (likely "data update" heartbeats or status messages), not actual candle data updates tvws:246-252 .

## Pros and Cons of Unsubscribing

### Pros of Unsubscribing (in example app)

- **Cleaner logs**: No more "du" spam in the debug console<cite />
- **Resource efficiency**: Fewer event handlers processing irrelevant events<cite />
- **Clearer intent**: Makes it obvious the connection is only for data fetching, not real-time monitoring<cite />

### Cons of Unsubscribing

- **Loss of debugging visibility**: You won't see connection health indicators (the "du" events show the connection is alive)<cite />
- **Can't detect disconnections**: Without event monitoring, you won't know if the WebSocket drops<cite />
- **Harder to implement real-time features later**: If you want to add live price updates, you'd need to re-architect the subscription model<cite />

## How to Implement Real-time Updates

If you want actual real-time price updates, you would need to:

1. **Keep the chart session alive** - Don't unsubscribe after `series_completed`<cite />
2. **Continue listening for `timescale_update` events** - These contain new candle data as it arrives tvws:659-666
3. **Handle incremental updates** - New candles will be appended to the series<cite />

The current library design doesn't support this out-of-the-box because the data fetching functions are designed for **historical data retrieval**, not real-time streaming tvws:223-233 .

## Notes

The example application's broad subscription at `example/script.js:332-334` is purely for debugging purposes and has no functional impact on data fetching. You could safely remove it or filter it to only log specific event types (as suggested in the previous response about log levels). The "du" events appearing every 5-7 seconds are just connection heartbeats and don't carry any market data<cite />.

Wiki pages you might want to explore:
- [Core Library API (badsector666/tvws)](/wiki/badsector666/tvws#3)
### Citations
**File:** src/index.ts (L27-31)
```typescript
interface TradingviewConnection {
  subscribe: (handler: Subscriber) => Unsubscriber;
  send: (name: string, params: any[]) => void;
  close: () => Promise<void>;
}
```
**File:** src/index.ts (L206-213)
```typescript
  const subscribers: Set<Subscriber> = new Set();

  function subscribe(handler: Subscriber): Unsubscriber {
    subscribers.add(handler);
    return () => {
      subscribers.delete(handler);
    };
  }
```
**File:** src/index.ts (L246-252)
```typescript
          case "event":
            const tradingEvent = {
              name: payload.data.m,
              params: payload.data.p,
            };
            subscribers.forEach((handler) => handler(tradingEvent));
            break;
```
**File:** src/index.ts (L368-369)
```typescript
            unsubscribe();
            resolve(results);
```
**File:** src/index.ts (L510-512)
```typescript
        if (activeCount === 0) {
          unsubscribe();
        }
```
**File:** src/index.ts (L659-666)
```typescript
      if (event.name === "timescale_update") {
        let newCandles: RawCandle[] = event.params[1]["sds_1"]["s"];
        if (newCandles.length > batchSize) {
          // sometimes tradingview sends already received candles
          newCandles = newCandles.slice(0, -currentSymCandles.length);
        }
        currentSymCandles = newCandles.concat(currentSymCandles);
        return;
```
**File:** src/index.ts (L670-725)
```typescript
      if (["series_completed", "symbol_error"].includes(event.name)) {
        const loadedCount = currentSymCandles.length;
        if (
          loadedCount > 0 &&
          loadedCount % batchSize === 0 &&
          (!amount || loadedCount < amount)
        ) {
          connection.send("request_more_data", [
            chartSession,
            "sds_1",
            batchSize,
          ]);
          return;
        }

        // loaded all candles for current symbol

        if (amount) currentSymCandles = currentSymCandles.slice(0, amount);

        const candles = currentSymCandles.map((c) => ({
          timestamp: c.v[0],
          open: c.v[1],
          high: c.v[2],
          low: c.v[3],
          close: c.v[4],
          volume: c.v[5],
        }));
        allCandles.push(candles);

        // next symbol
        if (symbols.length - 1 > currentSymIndex) {
          currentSymCandles = [];
          currentSymIndex += 1;
          symbol = symbols[currentSymIndex];
          connection.send("resolve_symbol", [
            chartSession,
            `sds_sym_${currentSymIndex}`,
            "=" + JSON.stringify({ symbol, adjustment: "splits" }),
          ]);

          const validatedTimeframe = validateTimeframe(timeframe);
          connection.send("modify_series", [
            chartSession,
            "sds_1",
            `s${currentSymIndex}`,
            `sds_sym_${currentSymIndex}`,
            validatedTimeframe,
            "",
          ]);
          return;
        }

        // all symbols loaded
        unsubscribe();
        resolve(allCandles);
      }
```
**File:** src/index.ts (L728-744)
```typescript
    connection.send("chart_create_session", [chartSession, ""]);
    connection.send("resolve_symbol", [
      chartSession,
      `sds_sym_0`,
      "=" + JSON.stringify({ symbol, adjustment: "splits" }),
    ]);
    const validatedTimeframe = validateTimeframe(timeframe);
    connection.send("create_series", [
      chartSession,
      "sds_1",
      "s0",
      "sds_sym_0",
      validatedTimeframe,
      batchSize,
      "",
    ]);
  });
```
**File:** example/script.js (L332-334)
```javascript
    connection.subscribe((event) => {
      log(`📡 Real-time event: ${event.name}`, "info");
    });
```
**File:** README.MD (L223-233)
```markdown
### `getCandles(params: GetCandlesParams): Promise<CandleData[]>`

Fetches historical candlestick data for specified symbols.

**Parameters:**
- `connection: TradingviewConnection` - Active connection instance
- `symbols: string[]` - Array of trading symbols
- `amount?: number` - Number of candles to fetch (1-500, default: maximum available)
- `timeframe?: string | number` - Chart timeframe (default: "1D")

**Returns:** Array of candle arrays, one per symbol in the order provided
```
## Q4
Why don't we implement toggle function for this realtime? As you say in pros and cons, we need this toggle so the user can have flexibility of choice. How about my idea?
### Answer
Your idea of implementing a toggle function for real-time event logging is excellent! This would give users control over whether they want to see the "du" events and other real-time WebSocket messages in the debug log.

## What You're Proposing

You want to add a toggle control in the example application that allows users to enable/disable the real-time event subscription that currently logs all WebSocket events tvws:331-334 .

## Implementation Approach

Here's how to implement this toggle:

### 1. Add Toggle State Variable

Add a global variable to track the real-time logging state in `example/script.js` tvws:1-5 :

```javascript
let connection = null;
let tvwsModule = null;
let realtimeSubscription = null; // Track the subscription
let realtimeLoggingEnabled = false; // Toggle state
```

### 2. Create Subscribe/Unsubscribe Functions

Add functions to manage the real-time event subscription:

```javascript
function enableRealtimeLogging() {
  if (!connection || realtimeSubscription) return;

  realtimeSubscription = connection.subscribe((event) => {
    log(`📡 Real-time event: ${event.name}`, "debug");
  });

  realtimeLoggingEnabled = true;
  log("✅ Real-time event logging enabled", "info");
}

function disableRealtimeLogging() {
  if (realtimeSubscription) {
    realtimeSubscription.unsubscribe();
    realtimeSubscription = null;
  }

  realtimeLoggingEnabled = false;
  log("⏸️ Real-time event logging disabled", "info");
}

function toggleRealtimeLogging() {
  if (realtimeLoggingEnabled) {
    disableRealtimeLogging();
  } else {
    enableRealtimeLogging();
  }

  // Update toggle button state
  const toggleBtn = document.getElementById("realtimeToggleBtn");
  if (toggleBtn) {
    toggleBtn.textContent = realtimeLoggingEnabled
      ? "⏸️ Disable Real-time Events"
      : "▶️ Enable Real-time Events";
  }
}
```

### 3. Update Connection Functions

Modify both `quickConnect()` and `testConnection()` to NOT automatically subscribe. Remove the subscription code tvws:257-260  and tvws:331-334 , and instead let users control it via the toggle.

### 4. Add UI Toggle Button

Add a toggle button in the debug log section of `example/index.html` tvws:312-316 :

```html
<div class="debug-log compact">
    <h3>📋 Debug Log</h3>
    <div class="form-group">
        <button
            id="realtimeToggleBtn"
            class="btn btn-outline"
            onclick="toggleRealtimeLogging()"
            disabled
        >
            ▶️ Enable Real-time Events
        </button>
    </div>
    <div id="log" class="log-container"></div>
</div>
```

### 5. Enable Toggle After Connection

In both connection functions, enable the toggle button after successful connection:

```javascript
// In quickConnect() and testConnection(), after connection succeeds:
const realtimeToggleBtn = document.getElementById("realtimeToggleBtn");
if (realtimeToggleBtn) {
  realtimeToggleBtn.disabled = false;
}
```

### 6. Expose Function Globally

Add to `setupGlobalFunctions()` tvws:46-115 :

```javascript
window.toggleRealtimeLogging = function() {
  console.log("toggleRealtimeLogging called via window");
  return toggleRealtimeLogging();
};
```

## Benefits of This Approach

1. **User Control**: Users can enable real-time logging only when they need to debug connection issues<cite />
2. **Cleaner Logs**: By default, logs won't be cluttered with "du" events<cite />
3. **Resource Efficient**: Reduces unnecessary event processing when not needed<cite />
4. **Debugging Flexibility**: Users can toggle it on/off without reconnecting<cite />
5. **Connection Health Monitoring**: When enabled, users can verify the WebSocket is alive via the periodic "du" events<cite />

## Notes

This toggle would work perfectly with the log level filtering system discussed earlier. You could set real-time events to "debug" level, so when users set log level to "info" or higher, they won't see them even if the toggle is enabled. This gives users two layers of control: the toggle for subscribing/unsubscribing, and the log level for filtering what gets displayed<cite />.

Wiki pages you might want to explore:
- [Example Application (badsector666/tvws)](/wiki/badsector666/tvws#5)
### Citations
**File:** example/script.js (L1-5)
```javascript
// TradingView WebSocket Example - Complete Functionality
// Using dynamic import to avoid Bun bundler issues with external CDN modules
let connection = null;
let tvwsModule = null;

```
**File:** example/script.js (L46-115)
```javascript
// Function to set up all global functions
function setupGlobalFunctions() {
  try {
    // Make all functions globally available to HTML onclick handlers
    window.toggleAuthFields = function () {
      console.log("toggleAuthFields called via window");
      return toggleAuthFields();
    };

    window.showSessionHelp = function () {
      console.log("showSessionHelp called via window");
      return showSessionHelp();
    };

    window.hideSessionHelp = function () {
      console.log("hideSessionHelp called via window");
      return hideSessionHelp();
    };

    window.quickConnect = function () {
      console.log("quickConnect called via window");
      return quickConnect();
    };

    window.testConnection = function () {
      console.log("testConnection called via window");
      return testConnection();
    };

    window.loadData = function () {
      console.log("loadData called via window");
      return loadData();
    };

    window.clearResults = function () {
      console.log("clearResults called via window");
      return clearResults();
    };

    window.clearLog = function () {
      console.log("clearLog called via window");
      return clearLog();
    };

    window.selectPresetTicker = function () {
      console.log("selectPresetTicker called via window");
      return selectPresetTicker();
    };

    window.resetQueryForm = function () {
      console.log("resetQueryForm called via window");
      return resetQueryForm();
    };

    window.log = log;

    console.log("All global functions have been set up successfully");

    // Test that functions are accessible
    console.log("Testing function accessibility:");
    console.log(
      "- toggleAuthFields available:",
      typeof window.toggleAuthFields,
    );
    console.log("- quickConnect available:", typeof window.quickConnect);
    console.log("- loadData available:", typeof window.loadData);
  } catch (error) {
    console.error("Error setting up global functions:", error);
  }
}
```
**File:** example/script.js (L257-260)
```javascript
    // Subscribe to real-time events
    connection.subscribe((event) => {
      log(`📡 Real-time event: ${event.name}`, "info");
    });
```
**File:** example/script.js (L331-334)
```javascript
    // Subscribe to real-time events
    connection.subscribe((event) => {
      log(`📡 Real-time event: ${event.name}`, "info");
    });
```
**File:** example/index.html (L312-316)
```html
                <!-- Debug Log -->
                <div class="debug-log compact">
                    <h3>📋 Debug Log</h3>
                    <div id="log" class="log-container"></div>
                </div>
```
## Q5
Are we not refactor the index.ts for this changes? Because I think it's still the backbone of this repo, of course the example also need refactor but the changes in index.ts will benefit the entire user who use this.
### Answer
You're asking whether we should refactor `src/index.ts` to add the real-time event logging toggle functionality, rather than just implementing it in the example application.

## Current Architecture

The core library in `src/index.ts` is designed as a **low-level API** that provides building blocks for WebSocket communication tvws:27-31 . It exposes:

1. **Connection management** via `connect()` function tvws:572-625
2. **Subscription system** via `TradingviewConnection.subscribe()` tvws:208-213
3. **Data fetching functions** that handle their own subscriptions internally tvws:640-745

The data fetching functions (`getCandles`, `getCandlesConcurrent`, `getCandlesStream`) already implement proper subscription lifecycle management - they subscribe when starting data collection and unsubscribe when complete tvws:722-723 tvws:367-368 tvws:509-511 .

## Why NOT to Refactor index.ts

**The core library should remain unopinionated about logging and UI concerns**<cite />. Here's why:

1. **Separation of concerns**: `index.ts` provides the WebSocket primitives; applications decide how to use them<cite />. Adding logging toggles would mix presentation logic with data access logic<cite />.

2. **The subscription API is already flexible**: Users can already control subscriptions via the `subscribe()` method and its returned `unsubscribe()` function tvws:208-213 . This is exactly what the toggle implementation uses<cite />.

3. **Different use cases**: Some users might want to log to files, others to external monitoring systems, others not at all<cite />. The library shouldn't dictate this<cite />.

4. **The library already provides the tools**: The `TradingviewConnection` interface gives users everything they need to implement their own logging strategy tvws:27-31 :
   - `subscribe()` to listen to events
   - `send()` to communicate with TradingView
   - `close()` to clean up

## What index.ts Already Provides

The core library already gives users full control over event subscriptions tvws:208-213 :

```typescript
function subscribe(handler: Subscriber): Unsubscriber {
  subscribers.add(handler);
  return () => {
    subscribers.delete(handler);
  };
}
```

This design allows **any application** to implement their own toggle logic by:
1. Calling `connection.subscribe()` to start listening
2. Storing the returned unsubscribe function
3. Calling that function to stop listening

The example application's toggle implementation leverages this existing API perfectly<cite />.

## What Could Be Added (Optional)

If you want to make the library more helpful for common use cases, you could add **optional utility functions** without changing the core API:

```typescript
// Optional helper in index.ts
export function createEventLogger(
  connection: TradingviewConnection,
  filter?: (event: TradingviewEvent) => boolean
): { start: () => void; stop: () => void } {
  let unsubscribe: Unsubscriber | null = null;

  return {
    start: () => {
      if (unsubscribe) return;
      unsubscribe = connection.subscribe((event) => {
        if (!filter || filter(event)) {
          console.log('Event:', event.name, event.params);
        }
      });
    },
    stop: () => {
      if (unsubscribe) {
        unsubscribe();
        unsubscribe = null;
      }
    }
  };
}
```

However, this is **not necessary** because the existing API already enables this pattern<cite />.

## Notes

The example application is the right place for UI-specific features like toggles and log level controls<cite />. The core library's job is to provide a clean, minimal API for WebSocket communication tvws:27-31 . Users who want different logging behavior can implement it using the existing `subscribe()` API, just like the example does<cite />. This keeps the library focused and maintainable while giving users maximum flexibility<cite />.

Wiki pages you might want to explore:
- [Core Library API (badsector666/tvws)](/wiki/badsector666/tvws#3)
### Citations
**File:** src/index.ts (L27-31)
```typescript
interface TradingviewConnection {
  subscribe: (handler: Subscriber) => Unsubscriber;
  send: (name: string, params: any[]) => void;
  close: () => Promise<void>;
}
```
**File:** src/index.ts (L208-213)
```typescript
  function subscribe(handler: Subscriber): Unsubscriber {
    subscribers.add(handler);
    return () => {
      subscribers.delete(handler);
    };
  }
```
**File:** src/index.ts (L367-368)
```typescript
          if (completedCount === symbols.length) {
            unsubscribe();
```
**File:** src/index.ts (L509-511)
```typescript
        // Clean up if all symbols are done
        if (activeCount === 0) {
          unsubscribe();
```
**File:** src/index.ts (L572-625)
```typescript
export async function connect(
  options: ConnectionOptions = {},
): Promise<TradingviewConnection> {
  // Determine WebSocket endpoint
  let endpointName: string;
  let wsUrl: string;

  if (options.endpoint && Object.keys(ENDPOINTS).includes(options.endpoint)) {
    // If named endpoint provided
    endpointName = options.endpoint;
    wsUrl = ENDPOINTS[options.endpoint as TradingviewEndpoint];
  } else if (options.endpoint && options.endpoint.startsWith("wss://")) {
    // If custom endpoint provided
    endpointName = "custom";
    wsUrl = options.endpoint;
  } else {
    // Default to data endpoint for free users
    endpointName = "data";
    wsUrl = ENDPOINTS.data;
  }

  // Try to connect with fallback to other endpoints
  const endpointsToTry = [
    { name: endpointName, url: wsUrl },
    // Add fallback endpoints (excluding the one we already tried)
    ...Object.entries(ENDPOINTS)
      .filter(([name]) => name !== endpointName)
      .map(([name, url]) => ({ name, url })),
  ];

  let lastError: Error | null = null;

  for (const endpoint of endpointsToTry) {
    try {
      console.log(
        `Attempting connection to ${endpoint.name} endpoint: ${endpoint.url}`,
      );
      const connection = await connectToEndpoint(
        options,
        endpoint.name,
        endpoint.url,
      );
      console.log(`Successfully connected to ${endpoint.name} endpoint`);
      return connection;
    } catch (error) {
      lastError = error as Error;
      console.warn(`Failed to connect to ${endpoint.name} endpoint:`, error);
      // Continue to next endpoint
    }
  }

  // If all endpoints failed, throw the last error
  throw lastError || new Error("Failed to connect to any TradingView endpoint");
}
```
**File:** src/index.ts (L640-745)
```typescript
export async function getCandles({
  connection,
  symbols,
  amount,
  timeframe = 60,
}: GetCandlesParams) {
  if (symbols.length === 0) return [];

  const chartSession = "cs_" + Math.random().toString(36).substring(2, 14);
  const batchSize = amount && amount < MAX_BATCH_SIZE ? amount : MAX_BATCH_SIZE;

  return new Promise<Candle[][]>((resolve) => {
    const allCandles: Candle[][] = [];
    let currentSymIndex = 0;
    let symbol = symbols[currentSymIndex];
    let currentSymCandles: RawCandle[] = [];

    const unsubscribe = connection.subscribe((event) => {
      // received new candles
      if (event.name === "timescale_update") {
        let newCandles: RawCandle[] = event.params[1]["sds_1"]["s"];
        if (newCandles.length > batchSize) {
          // sometimes tradingview sends already received candles
          newCandles = newCandles.slice(0, -currentSymCandles.length);
        }
        currentSymCandles = newCandles.concat(currentSymCandles);
        return;
      }

      // loaded all requested candles
      if (["series_completed", "symbol_error"].includes(event.name)) {
        const loadedCount = currentSymCandles.length;
        if (
          loadedCount > 0 &&
          loadedCount % batchSize === 0 &&
          (!amount || loadedCount < amount)
        ) {
          connection.send("request_more_data", [
            chartSession,
            "sds_1",
            batchSize,
          ]);
          return;
        }

        // loaded all candles for current symbol

        if (amount) currentSymCandles = currentSymCandles.slice(0, amount);

        const candles = currentSymCandles.map((c) => ({
          timestamp: c.v[0],
          open: c.v[1],
          high: c.v[2],
          low: c.v[3],
          close: c.v[4],
          volume: c.v[5],
        }));
        allCandles.push(candles);

        // next symbol
        if (symbols.length - 1 > currentSymIndex) {
          currentSymCandles = [];
          currentSymIndex += 1;
          symbol = symbols[currentSymIndex];
          connection.send("resolve_symbol", [
            chartSession,
            `sds_sym_${currentSymIndex}`,
            "=" + JSON.stringify({ symbol, adjustment: "splits" }),
          ]);

          const validatedTimeframe = validateTimeframe(timeframe);
          connection.send("modify_series", [
            chartSession,
            "sds_1",
            `s${currentSymIndex}`,
            `sds_sym_${currentSymIndex}`,
            validatedTimeframe,
            "",
          ]);
          return;
        }

        // all symbols loaded
        unsubscribe();
        resolve(allCandles);
      }
    });

    connection.send("chart_create_session", [chartSession, ""]);
    connection.send("resolve_symbol", [
      chartSession,
      `sds_sym_0`,
      "=" + JSON.stringify({ symbol, adjustment: "splits" }),
    ]);
    const validatedTimeframe = validateTimeframe(timeframe);
    connection.send("create_series", [
      chartSession,
      "sds_1",
      "s0",
      "sds_sym_0",
      validatedTimeframe,
      batchSize,
      "",
    ]);
  });
}
```
https://deepwiki.com/search/why-its-always-spam-message-re_08f30bfe-fdde-4aee-a3fd-df8d483adbcb?mode=fast
