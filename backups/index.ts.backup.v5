// Hierarchical WebSocket Event System for TradingView API
// Compressed, reactive, and composable implementation

// Base EventEmitter with hierarchical namespacing and wildcard support
type EventPattern = string;
type EventHandler<T = any> = (event?: string, data?: T) => void;

class EventEmitter {
  private listeners = new Map<EventPattern, Set<EventHandler>>();
  private wildcards: Array<{ pattern: string; handler: EventHandler }> = [];

  // Event subscription with method chaining
  on<T = any>(event: EventPattern, handler: EventHandler<T>): this {
    if (event.includes("*")) {
      this.wildcards.push({ pattern: event, handler });
    } else {
      if (!this.listeners.has(event)) this.listeners.set(event, new Set());
      this.listeners.get(event)!.add(handler);
    }
    return this;
  }

  // One-time event subscription
  once<T = any>(event: EventPattern, handler: EventHandler<T>): this {
    const wrapper = (e?: string, d?: T) => {
      handler(e, d);
      this.off(event, wrapper);
    };
    return this.on(event, wrapper);
  }

  // Event unsubscription
  off(event: EventPattern, handler: EventHandler): this {
    const handlers = this.listeners.get(event);
    if (handlers) handlers.delete(handler);
    this.wildcards = this.wildcards.filter((w) => w.handler !== handler);
    return this;
  }

  // Event emission with hierarchical routing
  emit<T = any>(event: EventPattern, data?: T): void {
    // Direct listeners
    const handlers = this.listeners.get(event);
    if (handlers)
      handlers.forEach((h) => {
        try {
          h(event, data);
        } catch (e) {
          console.error(`Event error: ${event}`, e);
        }
      });

    // Wildcard pattern matching
    this.wildcards.forEach(({ pattern, handler }) => {
      if (this.matchPattern(event, pattern)) {
        try {
          handler(event, data);
        } catch (e) {
          console.error(`Wildcard error: ${pattern}`, e);
        }
      }
    });
  }

  // Pattern matching for wildcards
  private matchPattern(event: string, pattern: string): boolean {
    const eParts = event.split(":");
    const pParts = pattern.split(":");
    if (eParts.length !== pParts.length) return false;
    return pParts.every((part, i) => part === "*" || part === eParts[i]);
  }
}

// Packet types and interfaces
interface TWPacket {
  m?: string; // method type
  p?: any[]; // parameters [session_id, ...data]
}

interface SocketSession {
  session_id: string;
  timestamp: number;
  timestampMs: number;
  release: string;
  studies_metadata_hash: string;
  protocol: string;
  javastudies: string;
  auth_scheme_vsn: number;
  via: string;
}

// Session types
type SessionType = "chart" | "quote" | "replay" | "study";

// Base session class
abstract class BaseSession extends EventEmitter {
  abstract readonly sessionType: SessionType;
  abstract readonly id: string;

  constructor(public client: TVWSClient) {
    super();
  }

  abstract handlePacket(packet: TWPacket): void;

  // Method chaining for event handlers
  onData<T = any>(handler: EventHandler<T>): this {
    return this.on("data", handler);
  }

  onError(handler: ErrorHandler): this {
    return this.on("error", handler);
  }
}

type ErrorHandler = EventHandler<string | Error>;

// Chart session implementation
class ChartSession extends BaseSession {
  readonly sessionType = "chart" as const;
  readonly id: string;
  private periods = new Map<number, any>();
  private infos: any = {};

  constructor(client: TVWSClient) {
    super(client);
    this.id = `cs_${Math.random().toString(36).substr(2, 9)}`;
    client.registerSession(this);
    this.init();
  }

  private init(): void {
    this.client.send("chart_create_session", [this.id]);
    // Subscribe to chart-specific events
    this.client.on(`chart:${this.id}:*`, (event, packet) => {
      const eventType = event?.split(":")[2];
      if (eventType && packet) this.handlePacket({ m: eventType, p: packet });
    });
  }

  handlePacket(packet: TWPacket): void {
    const type = packet.m;
    const data = packet.p;

    switch (type) {
      case "symbol_resolved":
        this.infos = { series_id: data?.[1], ...data?.[2] };
        this.emit("symbolLoaded", this.infos);
        break;
      case "timescale_update":
      case "du":
        const changes = this.processUpdate(data?.[1]);
        this.emit("update", changes);
        break;
      case "symbol_error":
        this.emit("error", `Symbol error: ${data?.[2]}`);
        break;
      case "series_error":
        this.emit("error", `Series error: ${data?.[3]}`);
        break;
      case "critical_error":
        this.emit("error", `Critical error: ${data?.[1]} - ${data?.[2]}`);
        break;
    }
  }

  private processUpdate(updateData: any): string[] {
    const changes = Object.keys(updateData || {});

    if (updateData?.$prices?.s) {
      updateData.$prices.s.forEach((p: any) => {
        this.periods.set(p.v[0], {
          time: p.v[0],
          open: p.v[1],
          close: p.v[4],
          max: p.v[2],
          min: p.v[3],
          volume: Math.round(p.v[5] * 100) / 100,
        });
      });
    }

    return changes;
  }

  // Method chaining API
  setSymbol(symbol: string, options: any = {}): this {
    const symbolData = `=${JSON.stringify({
      symbol,
      adjustment: "splits",
      session: "regular",
      ...options,
    })}`;
    this.client.send("resolve_symbol", [this.id, "symbol_1", symbolData]);
    return this;
  }

  setTimeframe(timeframe: string, range: number = 300): this {
    this.periods.clear();
    this.client.send("create_series", [
      this.id,
      "$prices",
      "s1",
      "symbol_1",
      timeframe,
      range,
      "",
    ]);
    return this;
  }

  getLatestPrices(): any[] {
    return Array.from(this.periods.values()).sort((a, b) => b.time - a.time);
  }

  getInfos(): any {
    return this.infos;
  }

  delete(): void {
    this.client.send("chart_delete_session", [this.id]);
    this.client.unregisterSession(this.id);
  }
}

// Quote session implementation
class QuoteSession extends BaseSession {
  readonly sessionType = "quote" as const;
  readonly id: string;
  private symbols = new Set<string>();

  constructor(client: TVWSClient) {
    super(client);
    this.id = `qs_${Math.random().toString(36).substr(2, 9)}`;
    client.registerSession(this);
    this.init();
  }

  private init(): void {
    this.client.send("quote_create_session", [this.id]);
    this.client.on(`quote:${this.id}:*`, (event, packet) => {
      const eventType = event?.split(":")[2];
      if (eventType && packet) this.handlePacket({ m: eventType, p: packet });
    });
  }

  handlePacket(packet: TWPacket): void {
    const type = packet.m;
    const data = packet.p;

    switch (type) {
      case "quote_completed":
        this.emit("loaded", data?.[1]);
        break;
      case "qsd":
        if (data?.[1]?.s === "ok") {
          this.emit("data", data[1].v);
        }
        break;
      case "critical_error":
        this.emit("error", `Quote error: ${data?.[1]} - ${data?.[2]}`);
        break;
    }
  }

  addSymbol(symbol: string): this {
    this.symbols.add(symbol);
    this.client.send("quote_add_symbols", [this.id, symbol]);
    return this;
  }

  removeSymbol(symbol: string): this {
    this.symbols.delete(symbol);
    this.client.send("quote_remove_symbols", [this.id, symbol]);
    return this;
  }

  delete(): void {
    this.client.send("quote_delete_session", [this.id]);
    this.client.unregisterSession(this.id);
  }
}

// Unified WebSocket client
class TVWSClient extends EventEmitter {
  private ws?: WebSocket;
  private sessions = new Map<string, BaseSession>();
  private sendQueue: string[] = [];
  private logged = false;
  private sessionCallbacks = new Map<SessionType, Set<EventHandler>>();

  constructor(private options: any = {}) {
    super();
    this.connect();
  }

  private connect(): void {
    const server = this.options.server || "data";
    this.ws = new WebSocket(
      `wss://${server}.tradingview.com/socket.io/websocket?type=chart`,
    );

    this.ws.onopen = () => {
      this.emit("client:connected");
      this.authenticate();
    };

    this.ws.onclose = () => {
      this.logged = false;
      this.emit("client:disconnected");
    };

    this.ws.onerror = (err) => {
      this.emit("client:error", err);
    };

    this.ws.onmessage = (msg) => this.handleMessage(msg.data);
  }

  private async authenticate(): Promise<void> {
    try {
      if (this.options.token) {
        // Would need getUser implementation here
        this.send("set_auth_token", [this.options.token]);
      } else {
        this.send("set_auth_token", ["unauthorized_user_token"]);
      }
      this.logged = true;
      this.emit("client:logged");
      this.flushQueue();
    } catch (err) {
      this.emit("client:error", `Auth failed: ${err}`);
    }
  }

  private handleMessage(data: string): void {
    const packets = this.parsePackets(data);
    packets.forEach((packet) => {
      if (typeof packet === "number") {
        this.ws?.send(this.formatPacket(`~h~${packet}`));
        this.emit("client:ping", packet);
        return;
      }

      if (packet.m === "protocol_error") {
        this.emit("client:error", packet.p);
        this.ws?.close();
        return;
      }

      if (packet.m && packet.p) {
        const sessionId = packet.p[0];
        const session = this.sessions.get(sessionId);

        if (session) {
          const event = `${session.sessionType}:${sessionId}:${packet.m}`;
          this.emit(event, packet.p);
        } else if (!this.logged) {
          this.emit("client:logged", packet);
        } else {
          this.emit("client:data", packet);
        }
      }
    });
  }

  private parsePackets(str: string): (TWPacket | number)[] {
    return str
      .replace(/~h~/g, "")
      .split(/~m~\d+~m~/)
      .map((p) => {
        if (!p) return null;
        try {
          return JSON.parse(p);
        } catch {
          return null;
        }
      })
      .filter((p) => p !== null) as (TWPacket | number)[];
  }

  private formatPacket(packet: any): string {
    const msg = typeof packet === "object" ? JSON.stringify(packet) : packet;
    return `~m~${msg.length}~m~${msg}`;
  }

  send(method: string, params: any[] = []): void {
    const packet = { m: method, p: params };
    this.sendQueue.push(this.formatPacket(packet));
    this.flushQueue();
  }

  private flushQueue(): void {
    while (
      this.ws?.readyState === WebSocket.OPEN &&
      this.logged &&
      this.sendQueue.length > 0
    ) {
      this.ws.send(this.sendQueue.shift()!);
    }
  }

  registerSession(session: BaseSession): void {
    this.sessions.set(session.id, session);
  }

  unregisterSession(sessionId: string): void {
    this.sessions.delete(sessionId);
  }

  // Session factory with method chaining
  createChart(): ChartSession {
    return new ChartSession(this);
  }

  createQuote(): QuoteSession {
    return new QuoteSession(this);
  }

  // Convenience methods with chaining
  onConnected(handler: EventHandler): this {
    return this.on("client:connected", handler);
  }

  onLogged(handler: EventHandler<SocketSession>): this {
    return this.on("client:logged", handler);
  }

  onError(handler: ErrorHandler): this {
    return this.on("client:error", handler);
  }

  close(): Promise<void> {
    return new Promise((resolve) => {
      if (this.ws?.readyState === WebSocket.OPEN) {
        this.ws.close();
      }
      resolve();
    });
  }

  get isOpen(): boolean {
    return this.ws?.readyState === WebSocket.OPEN;
  }
}

// Public API factory function
export function createClient(options?: any): TVWSClient {
  return new TVWSClient(options);
}

// Convenience export for direct usage
export function connect(options?: any): TVWSClient {
  return createClient(options);
}

// Export classes for extensibility
export { EventEmitter, TVWSClient, ChartSession, QuoteSession };

// Type exports
export type {
  EventPattern,
  EventHandler,
  SocketSession,
  SessionType,
  TWPacket,
};

// Global browser exposure (will be handled by build script)
declare global {
  interface Window {
    tvws?: { createClient: typeof createClient; connect: typeof connect };
  }
}

export default { createClient, connect };
